# Отличия Kernel mode и User mode

Для защиты пользовательских приложений от доступа к критическим данным ОС и/или их изменения Windows использует два режима доступа процессора (даже если процессор, на котором работает Windows, поддерживает более двух режимов): _пользовательский режим_ и _режим ядра_. Код пользовательских приложений запускается в пользовательском режиме, тогда как код ОС (например, системные службы и драйверы устройств) работает в режиме ядра. Режим ядра относится к режиму выполнения процессора, который предоставляет доступ ко всей памяти системы и всем инструкциям CPU. Некоторые процессоры различают такие режимы, используя термины _уровень привилегий кода_ или _уровень кольца_, в то время как другие используют термины _режим супервизора_ и _аппликационный режим_. Независимо от названия, предоставляя ядру операционной системы более высокий уровень привилегий, чем пользовательским приложениям, процессор обеспечивает необходимую основу для разработчиков ОС, чтобы гарантировать, что неправильно работающие приложения не могут нарушить стабильность системы в целом.

{% hint style="info" %}
Архитектуры процессоров x86 и x64 определяют четыре уровня привилегий (или кольца) для защиты системного кода и данных от ненамеренного или злонамеренного изменения кодом с меньшими привилегиями. Windows использует уровень привилегий 0 (или кольцо 0) для режима ядра и уровень привилегий 3 (или кольцо 3) для пользовательского режима. Причина, по которой Windows использует только два уровня, заключается в том, что некоторые аппаратные архитектуры, такие как ARM сегодня и MIPS/Alpha в прошлом, реализовали только два уровня привилегий. Установление минимального порога позволило создать более эффективную и портативную архитектуру, особенно учитывая, что другие уровни кольца x86/x64 не обеспечивают тех же гарантий, что и разделение кольцо 0/кольцо 3.
{% endhint %}

Несмотря на то, что каждый процесс в Windows имеет собственное приватное адресное пространство, код ядра ОС и драйверы устройств используют единое виртуальное адресное пространство. Каждая страница в виртуальной памяти помечается для указания режима доступа, необходимого процессору для чтения и/или записи этой страницы. Страницы в системном пространстве могут быть доступны только из режима ядра, тогда как все страницы в пользовательском адресном пространстве доступны из пользовательского и режима ядра. Страницы только для чтения (например, содержащие статические данные) не могут быть изменены ни в одном из режимов. Более того, на процессорах, поддерживающих защиту от выполнения, Windows помечает страницы, содержащие данные, как неисполняемые, чтобы предотвратить непреднамеренное или вредоносное выполнение кода в областях данных (если эта функция, предотвращение выполнения данных \[DEP], включена).

Windows не обеспечивает защиты закрытой системной памяти для чтения и записи, используемой компонентами, работающими в режиме ядра. Иными словами, как только компонент переходит в режим ядра, код операционной системы и драйверов получает полный доступ к памяти системного пространства и может обходить безопасность Windows для доступа к объектам. Поскольку основная часть кода Windows OS работает в режиме ядра, крайне важно, чтобы компоненты в этом режиме были тщательно разработаны и протестированы, чтобы обеспечить безопасность системы и её стабильность.

Отсутствие защиты также подчеркивает необходимость быть внимательным при загрузке драйвера устройства от стороннего производителя, особенно если он не подписан, поскольку в режиме ядра драйвер имеет полный доступ ко всем данным ОС. Этот риск был одной из причин введения механизма подписи драйверов в Windows 2000, который предупреждает (и, если настроен, блокирует) пользователя при попытке добавить неподписанный драйвер plug-and-play (см. Главу 6, «Система ввода-вывода», для получения дополнительной информации о подписи драйверов), но не затрагивает другие типы драйверов. Также механизм под названием Driver Verifier помогает разработчикам драйверов находить ошибки, такие как переполнение буфера или утечки памяти, которые могут вызывать проблемы с безопасностью или надежностью. (В главе 6 также обсуждается Driver Verifier.)

На 64-битных и ARM версиях Windows 8.1, политика подписывания кода в режиме ядра (KMCS) требует, чтобы все драйверы устройств (не только подключаемые) были подписаны криптографическим ключом, выданным одним из основных центров сертификации кода. Пользователь не может явно принудительно установить неподписанный драйвер, даже будучи администратором. Однако в виде одноразового исключения это ограничение можно отключить вручную. Это позволяет драйверам быть самоподписанными и протестированными, добавляет водяной знак на обои рабочего стола с надписью «Test Mode» и отключает некоторые функции управления цифровыми правами (DRM).

В Windows 10 Microsoft внесла еще более значительное изменение, которое вступило в силу через год после выпуска в рамках июльского обновления Anniversary Update (версия 1607). С того времени все новые драйверы Windows 10 должны быть подписаны только двумя из принятых сертификационных центров с помощью...

Для получения расширенного сертификата SHA-2 с расширенной проверкой (EV) вместо стандартного сертификата SHA-1 на основе файлов и его 20 властей необходимо пройти аттестацию. После применения EV-подписи драйвер оборудования должен быть отправлен в Microsoft через портал System Device (SysDev) для аттестационной подписи, что обеспечит получение драйвером подписи Microsoft. Таким образом, ядро будет подписывать только драйверы Windows 10, подписанные Microsoft, без каких-либо исключений, кроме упомянутого режима тестирования. Драйверы, подписанные до даты релиза Windows 10 (июль 2015 года), могут продолжать загружаться с их обычной подписью на данный момент.

Как видно в Главе 2, «Архитектура системы», приложения пользователя переключаются из пользовательского режима в режим ядра, когда они делают системный вызов. Например, функция Windows ReadFile в конечном итоге должна вызвать внутреннюю процедуру Windows, которая фактически обрабатывает чтение данных из файла. Эта процедура, поскольку она обращается к внутренним структурам данных системы, должна выполняться в режиме ядра. Специальная инструкция процессора вызывает переход из пользовательского режима в режим ядра и заставляет процессор войти в код диспетчеризации системных служб в ядре. Это, в свою очередь, вызывает соответствующую внутреннюю функцию в Ntoskrnl.exe или Win32k.sys. Перед возвращением управления потоку пользователя режим процессора переключается обратно в пользовательский режим. Таким образом, ОС защищает себя и свои данные от просмотра и модификации пользовательскими процессами.

{% hint style="info" %}
Обратите внимание, что переход из пользовательского режима в режим ядра (и обратно) сам по себе не влияет на планирование потоков. Переход режима _не_ является переключением контекста. Дополнительные сведения о диспетчеризации системных служб приведены в главе 2.
{% endhint %}

Таким образом, нормально, что поток пользователя проводит часть времени в пользовательском режиме, а часть — в режиме ядра. Фактически, из-за того, что большая часть графической и оконной системы также работает в режиме ядра, графически насыщенные приложения тратят больше времени в режиме ядра, чем в пользовательском режиме. Легкий способ протестировать это — запустить графически насыщенное приложение, такое как Microsoft Paint, и наблюдать за распределением времени между пользовательским и режимом ядра с помощью одного из счетчиков производительности, перечисленных в Таблице 1-3. Более продвинутые приложения могут использовать новые технологии, такие как Direct2D и DirectComposition, которые выполняют основные вычисления в пользовательском режиме и отправляют только необработанные данные поверхности в ядро. Это сокращает время, затрачиваемое на переходы между режимами пользователя и ядра.

<table data-header-hidden><thead><tr><th valign="top"></th><th valign="top"></th></tr></thead><tbody><tr><td valign="top">Объект: Счетчик</td><td valign="top">Функции</td></tr><tr><td valign="top">Processor: % Privileged Time</td><td valign="top">Процент времени, в течение которого отдельный ЦП (или все ЦП) работал в режиме ядра за указанный интервал.</td></tr><tr><td valign="top">Processor: % User Time</td><td valign="top">Процент времени, в течение которого отдельный процессор (или все процессоры) работал в пользовательском режиме за заданный интервал.</td></tr><tr><td valign="top">Process: % Privileged Time</td><td valign="top">Процент времени, в течение которого потоки в процессе выполнялись в режиме ядра за указанный интервал.</td></tr><tr><td valign="top">Process: % User Time</td><td valign="top">Процент времени, в течение которого потоки в процессе выполнялись в пользовательском режиме за заданный интервал времени.</td></tr><tr><td valign="top">Thread: % Privileged Time</td><td valign="top">Процент времени, в течение которого поток работал в режиме ядра в заданном интервале времени.</td></tr><tr><td valign="top">Thread: % User Time</td><td valign="top">Процент времени, в течение которого поток работал в режиме пользователя за указанный интервал времени.</td></tr></tbody></table>
